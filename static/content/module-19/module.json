{
  "id": 15,
  "title": "אלגוריתמים – Two Pointers ו-Sliding Window",
  "theoryHTML": "<h2>מהם Two Pointers?</h2><p>שיטה שבה משתמשים בשני מצביעים (אינדקסים) כדי לעבור על מבנה נתונים. לרוב אחד מתחיל בתחילת הרשימה והשני בסוף, או שניהם נעים בכיוונים שונים לפי הצורך. השיטה יעילה במיוחד לבעיות של חיפוש, השוואה ותתי-מערכים.</p><pre style='direction:ltr; text-align:left;'><code># דוגמה: בדיקת פלינדרום\ns = \"abba\"\nleft, right = 0, len(s)-1\nis_palindrome = True\nwhile left < right:\n    if s[left] != s[right]:\n        is_palindrome = False\n        break\n    left += 1\n    right -= 1\nprint(is_palindrome)  # פלט: True</code></pre><h2>מהו Sliding Window?</h2><p>שיטה שבה משתמשים בחלון (window) רציף שעובר על הרשימה. הגודל יכול להיות קבוע או משתנה. השיטה משמשת למציאת סכומים, ממוצעים, תתי-מחרוזות ייחודיות ועוד.</p><pre style='direction:ltr; text-align:left;'><code># דוגמה: סכום מקסימלי של תת-מערך בגודל k\nnums = [2,1,5,1,3,2]\n k = 3\nwindow_sum = sum(nums[:k])\nmax_sum = window_sum\nfor i in range(k, len(nums)):\n    window_sum += nums[i] - nums[i-k]\n    max_sum = max(max_sum, window_sum)\nprint(max_sum)  # פלט: 9</code></pre><h3>השוואה</h3><ul><li><b>Two Pointers:</b> פתרון בעיות חיפוש והשוואה בין שני צדדים.</li><li><b>Sliding Window:</b> פתרון בעיות עם חלונות רציפים, יעיל במיוחד לעיבוד רצפים גדולים.</li></ul><h3>סיכום</h3><p>שני האלגוריתמים הם טכניקות יעילות מאוד לבעיות על מערכים ומחרוזות, חוסכים זמן ריצה ומאפשרים פתרון פשוט יותר מאשר לולאות מקוננות.</p>",
    "examples": [
    {
      "title": "Two Pointers – בדיקת פלינדרום",
      "code": "s = \"abba\"\nleft, right = 0, len(s)-1\nwhile left < right:\n    if s[left] != s[right]:\n        print(\"לא פלינדרום\")\n        break\n    left += 1\n    right -= 1\nelse:\n    print(\"פלינדרום\")"
    },
    {
      "title": "Two Pointers – מציאת זוג מספרים שסכומם שווה ליעד",
      "code": "nums = [1,2,4,4]\ntarget = 8\nnums.sort()\nleft, right = 0, len(nums)-1\nwhile left < right:\n    s = nums[left] + nums[right]\n    if s == target:\n        print(True)\n        break\n    elif s < target:\n        left += 1\n    else:\n        right -= 1"
    },
    {
      "title": "Two Pointers – מיזוג שתי רשימות ממוינות",
      "code": "a = [1,3,5]\nb = [2,4,6]\nmerged = []\ni = j = 0\nwhile i < len(a) and j < len(b):\n    if a[i] < b[j]:\n        merged.append(a[i])\n        i += 1\n    else:\n        merged.append(b[j])\n        j += 1\nmerged.extend(a[i:])\nmerged.extend(b[j:])\nprint(merged)"
    },
    {
      "title": "Two Pointers – מציאת ההפרש הקטן ביותר בין איברים בשתי רשימות",
      "code": "a = [1,3,15,11,2]\nb = [23,127,235,19,8]\na.sort(); b.sort()\ni = j = 0\nmin_diff = float('inf')\nwhile i < len(a) and j < len(b):\n    min_diff = min(min_diff, abs(a[i]-b[j]))\n    if a[i] < b[j]:\n        i += 1\n    else:\n        j += 1\nprint(min_diff)"
    },
    {
      "title": "Two Pointers – בדיקת כפילויות ברשימה ממוינת",
      "code": "nums = [1,2,2,3,4]\nleft, right = 0, 1\nfound = False\nwhile right < len(nums):\n    if nums[left] == nums[right]:\n        found = True\n        break\n    left += 1\n    right += 1\nprint(found)"
    },
    {
      "title": "Sliding Window – סכום מקסימלי של תת־מערך באורך k",
      "code": "nums = [2,1,5,1,3,2]\nk = 3\nwindow_sum = sum(nums[:k])\nmax_sum = window_sum\nfor i in range(k, len(nums)):\n    window_sum += nums[i] - nums[i-k]\n    max_sum = max(max_sum, window_sum)\nprint(max_sum)"
    },
    {
      "title": "Sliding Window – תת־מחרוזת ייחודית הארוכה ביותר",
      "code": "s = \"abcabcbb\"\nseen = {}\nleft = 0\nmax_len = 0\nfor right, ch in enumerate(s):\n    if ch in seen and seen[ch] >= left:\n        left = seen[ch] + 1\n    seen[ch] = right\n    max_len = max(max_len, right - left + 1)\nprint(max_len)"
    },
    {
      "title": "Sliding Window – תת־מערך קצר ביותר שסכומו ≥ יעד",
      "code": "nums = [2,3,1,2,4,3]\ntarget = 7\nleft = 0\ncurr_sum = 0\nmin_len = float('inf')\nfor right in range(len(nums)):\n    curr_sum += nums[right]\n    while curr_sum >= target:\n        min_len = min(min_len, right - left + 1)\n        curr_sum -= nums[left]\n        left += 1\nprint(0 if min_len == float('inf') else min_len)"
    },
    {
      "title": "Sliding Window – ממוצע כל חלון בגודל k",
      "code": "nums = [1,3,2,6,-1,4,1,8,2]\nk = 5\nwindow_sum = sum(nums[:k])\nresult = [window_sum/k]\nfor i in range(k, len(nums)):\n    window_sum += nums[i] - nums[i-k]\n    result.append(window_sum/k)\nprint(result)"
    },
    {
      "title": "Sliding Window – ספירת תתי־מחרוזות עם עד K תווים שונים",
      "code": "s = \"abcba\"\nK = 2\ncount = 0\nfreq = {}\nleft = 0\nfor right, ch in enumerate(s):\n    freq[ch] = freq.get(ch,0)+1\n    while len(freq) > K:\n        freq[s[left]] -= 1\n        if freq[s[left]] == 0:\n            del freq[s[left]]\n        left += 1\n    count += right - left + 1\nprint(count)"
    }
  ],"exercises": [
  {
    "question": "תרגיל 1 – כתוב פונקציה שבודקת אם מחרוזת היא פלינדרום בעזרת Two Pointers.",
    "solution": "def is_palindrome(s):\n    left, right = 0, len(s)-1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\nprint(is_palindrome(\"abba\"))  # True\nprint(is_palindrome(\"abc\"))   # False"
  },
  {
    "question": "תרגיל 2 – כתוב פונקציה שמקבלת רשימה ממוינת ומחזירה True אם קיימים בה כפילויות (Two Pointers).",
    "solution": "def has_duplicates(nums):\n    left, right = 0, 1\n    while right < len(nums):\n        if nums[left] == nums[right]:\n            return True\n        left += 1\n        right += 1\n    return False\n\nprint(has_duplicates([1,2,2,3]))  # True\nprint(has_duplicates([1,2,3,4]))  # False"
  },
  {
    "question": "תרגיל 3 – כתוב פונקציה שממזגת שתי רשימות ממוינות לרשימה אחת (Two Pointers).",
    "solution": "def merge_sorted_lists(a, b):\n    i = j = 0\n    merged = []\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            merged.append(a[i])\n            i += 1\n        else:\n            merged.append(b[j])\n            j += 1\n    merged.extend(a[i:])\n    merged.extend(b[j:])\n    return merged\n\nprint(merge_sorted_lists([1,3,5],[2,4,6]))  # [1,2,3,4,5,6]"
  },
  {
    "question": "תרגיל 4 – כתוב פונקציה שמוצאת את זוג המספרים הקרובים ביותר ברשימה ממוינת.",
    "solution": "def closest_pair(nums):\n    nums.sort()\n    min_diff = float('inf')\n    pair = (None, None)\n    for i in range(len(nums)-1):\n        diff = nums[i+1] - nums[i]\n        if diff < min_diff:\n            min_diff = diff\n            pair = (nums[i], nums[i+1])\n    return pair\n\nprint(closest_pair([4,9,1,32,13]))  # (9,13)"
  },
  {
    "question": "תרגיל 5 – כתוב פונקציה שמוצאת את כל הזוגות ברשימה שסכומם קטן או שווה ליעד נתון.",
    "solution": "def all_pairs(nums, target):\n    nums.sort()\n    left, right = 0, len(nums)-1\n    result = []\n    while left < right:\n        if nums[left] + nums[right] <= target:\n            result.append((nums[left], nums[right]))\n            left += 1\n        else:\n            right -= 1\n    return result\n\nprint(all_pairs([1,2,3,4,5], 6))  # [(1,5), (2,4)]"
  },
  {
    "question": "תרגיל 6 – כתוב פונקציה שמחזירה את סכום תת־המערך המקסימלי באורך קבוע k (Sliding Window).",
    "solution": "def max_sum_subarray(nums, k):\n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i-k]\n        max_sum = max(max_sum, window_sum)\n    return max_sum\n\nprint(max_sum_subarray([2,1,5,1,3,2], 3))  # 9"
  },
  {
    "question": "תרגיל 7 – כתוב פונקציה שמחזירה את אורך תת־המחרוזת הייחודית הארוכה ביותר (Sliding Window).",
    "solution": "def longest_unique_substring(s):\n    seen = {}\n    left = 0\n    max_len = 0\n    for right, ch in enumerate(s):\n        if ch in seen and seen[ch] >= left:\n            left = seen[ch] + 1\n        seen[ch] = right\n        max_len = max(max_len, right - left + 1)\n    return max_len\n\nprint(longest_unique_substring(\"abcabcbb\"))  # 3"
  },
  {
    "question": "תרגיל 8 – כתוב פונקציה שמוצאת את אורך תת־המערך הקטן ביותר שסכומו ≥ יעד נתון (Sliding Window).",
    "solution": "def min_subarray_len(target, nums):\n    left = 0\n    curr_sum = 0\n    min_len = float('inf')\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        while curr_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n    return 0 if min_len == float('inf') else min_len\n\nprint(min_subarray_len(7, [2,3,1,2,4,3]))  # 2"
  },
  {
    "question": "תרגיל 9 – כתוב פונקציה שמחזירה רשימה של ממוצעי כל חלון בגודל k (Sliding Window).",
    "solution": "def avg_subarrays(nums, k):\n    result = []\n    window_sum = sum(nums[:k])\n    result.append(window_sum/k)\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i-k]\n        result.append(window_sum/k)\n    return result\n\nprint(avg_subarrays([1,3,2,6,-1,4,1,8,2], 5))\n# [2.2, 2.8, 2.4, 3.6, 2.8]"
  },
  {
    "question": "תרגיל 10 – כתוב פונקציה שמחזירה את מספר תתי־המחרוזות במחרוזת שמכילות לכל היותר K תווים שונים (Sliding Window).",
    "solution": "def substrings_with_k_distinct(s, K):\n    count = 0\n    freq = {}\n    left = 0\n    for right, ch in enumerate(s):\n        freq[ch] = freq.get(ch, 0) + 1\n        while len(freq) > K:\n            freq[s[left]] -= 1\n            if freq[s[left]] == 0:\n                del freq[s[left]]\n            left += 1\n        count += right - left + 1\n    return count\n\nprint(substrings_with_k_distinct(\"abcba\", 2))  # 10"
  }
]
,
  "quizzes": [
    {
      "title": "שאלון 1 – Two Pointers",
      "questions": [
        {
          "question": "מהי שיטת Two Pointers?",
          "options": ["שימוש בשני משתנים לא קשורים", "שימוש בשני אינדקסים כדי לפתור בעיות ברשימות/מחרוזות", "חיפוש בינארי", "לולאה כפולה"],
          "answer": 1
        },
        {
          "question": "כיצד בודקים פלינדרום בעזרת Two Pointers?",
          "options": ["השוואת כל האיברים אחד לאחד בלולאה אחת", "השוואת איברים מההתחלה והסוף בו זמנית", "שימוש ב-slice", "אי אפשר לבדוק פלינדרום כך"],
          "answer": 1
        },
        {
          "question": "מה זמן הריצה של Two Pointers בבעיה כמו בדיקת פלינדרום?",
          "options": ["O(n^2)", "O(n)", "O(log n)", "O(1)"],
          "answer": 1
        }
      ]
    },
    {
      "title": "שאלון 2 – Sliding Window",
      "questions": [
        {
          "question": "מהי שיטת Sliding Window?",
          "options": ["בדיקת כל האפשרויות בלולאות מקוננות", "שימוש בחלון רציף שנע ברשימה או מחרוזת", "מיון הרשימה לפני חיפוש", "חיפוש בינארי"],
          "answer": 1
        },
        {
          "question": "מתי כדאי להשתמש ב-Sliding Window?",
          "options": ["כשמחפשים תתי-מערכים או מחרוזות רציפים", "בכל מקרה", "רק במבנים ממוינים", "רק כשאין לולאות"],
          "answer": 0
        },
        {
          "question": "מה היתרון של Sliding Window לעומת לולאה כפולה?",
          "options": ["הוא לא עובד תמיד", "זמן ריצה קצר יותר – O(n) במקום O(n^2)", "דורש פחות זיכרון", "אין יתרון"],
          "answer": 1
        }
      ]
    }
  ]
}
